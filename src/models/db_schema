CREATE TABLE Roles (
    role_id SERIAL PRIMARY KEY,
    role_name VARCHAR(20) UNIQUE NOT NULL
);

INSERT INTO Roles (role_name) VALUES
    ('Client'), 
    ('Agent'),
    ('Admin');

CREATE TABLE Users (
    user_id SERIAL PRIMARY KEY,
    email VARCHAR(100) UNIQUE NOT NULL,
    role_id INT REFERENCES Roles(role_id) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    auth_id UUID REFERENCES auth.users(id) UNIQUE NOT NULL,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL
);

CREATE TABLE Locations (
    location_id SERIAL PRIMARY KEY,
    location_name VARCHAR(20) UNIQUE NOT NULL
);

INSERT INTO Locations (location_name) VALUES 
    ('Atlanta'), 
    ('Birmingham'), 
    ('30A');

CREATE TABLE Customers (
    id SERIAL PRIMARY KEY,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    phone VARCHAR(20) NOT NULL,
    created_at TIMESTAMP WITHOUT TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITHOUT TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    location INT REFERENCES Locations(location_id),
    city VARCHAR(20) NOT NULL,
    state VARCHAR(2) NOT NULL,
    zipcode VARCHAR(20) NOT NULL,
    address1 VARCHAR(100) NOT NULL,
    address2 VARCHAR(100) NULL
);

CREATE TABLE Request_Types (
    type_id SERIAL PRIMARY KEY,
    type_name VARCHAR(50) UNIQUE NOT NULL
);

INSERT INTO Request_Types (type_name) VALUES
    ('A/V Automation'), 
    ('Electrical'), 
    ('Lighting Control'), 
    ('Network/Wi-Fi'), 
    ('Security'), 
    ('Other');

CREATE TABLE Request_Support_Types (
  request_id BIGINT NOT NULL,
  type_id INTEGER NOT NULL,
  PRIMARY KEY (request_id, type_id),
  FOREIGN KEY (request_id) REFERENCES Requests(request_id) ON DELETE CASCADE,
  FOREIGN KEY (type_id) REFERENCES Request_Types(type_id) ON DELETE RESTRICT
);

CREATE TABLE Request_Status (
    status_id SERIAL PRIMARY KEY,
    status_name VARCHAR(50) UNIQUE NOT NULL,
    description TEXT NOT NULL
);

INSERT INTO Request_Status (status_name, description) VALUES
    ('NEW REQUEST', 'The ticket is open and awaiting handling'),
    ('SCHEDULED', 'The ticket is scheduled and awaiting resolution'),
    ('PROPOSAL REQUIRED', 'A proposal from sales is required to progress this ticket'),
    ('FOLLOW UP REQUIRED', 'Ticket was unable to be resolved and requires more attention'),
    ('COMPLETED', 'The ticket has been resolved or closed');

CREATE TABLE Requests (
    request_id SERIAL PRIMARY KEY,
    customer_id INT REFERENCES Customers(customer_id) NULL,
    user_id INT REFERENCES Users(user_id) NULL,
    description TEXT NOT NULL,
    status_id INT REFERENCES Request_Status(status_id) DEFAULT 1,
    location INT REFERENCES Locations(location_id), 
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT chk_ticket_creator CHECK (
        (customer_id IS NOT NULL AND user_id IS NULL) OR
        (customer_id IS NULL AND user_id IS NOT NULL)
    )
);

CREATE TABLE Comments (
    comment_id SERIAL PRIMARY KEY,
    request_id INT REFERENCES Requests(request_id),
    user_id INT REFERENCES Users(user_id) DEFAULT 1,
    comment_text TEXT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Enable RLS (row-level security) and policies will be defined as per user roles and access requirements
alter table users enable row level security;
create policy "Can view own user data." on users for select using (auth.uid() = id);
create policy "Can update own user data." on users for update using (auth.uid() = id);

-- Define Triggers to update updated_at column
CREATE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER users_before_update
BEFORE UPDATE ON users
FOR EACH ROW EXECUTE PROCEDURE update_updated_at_column();

CREATE TRIGGER requests_before_update
BEFORE UPDATE ON requests
FOR EACH ROW EXECUTE PROCEDURE update_updated_at_column();

CREATE TRIGGER comments_before_update
BEFORE UPDATE ON comments
FOR EACH ROW EXECUTE PROCEDURE update_updated_at_column();

-- Define Ingest Functions
CREATE OR REPLACE FUNCTION replicate_ingest_data()
RETURNS TRIGGER AS $$
DECLARE
    new_customer_id INT;
    new_request_id INT;
    type_id INT;
BEGIN
    -- Check if the email already exists in the Customers table
    SELECT id INTO new_customer_id FROM Customers WHERE email = NEW.client_email LIMIT 1;

    IF NOT FOUND THEN
        -- If not found, insert the client as a new customer and capture the customer_id
            -- Splitting client_name into first_name and last_name for simplicity
    INSERT INTO Customers (first_name, last_name, email, phone, location, created_at)
    VALUES (
        split_part(NEW.client_name, ' ', 1), -- Assuming first word as first name
        split_part(NEW.client_name, ' ', 2), -- Assuming rest as last name
        NEW.client_email,
        NEW.client_phone,
        NEW.created_at,
        NEW.location,
        CURRENT_TIMESTAMP
    )
        RETURNING id INTO new_customer_id;
    END IF;

    -- Insert the request
    INSERT INTO Requests (customer_id, description, status_id, location)
    VALUES (
        new_customer_id, 
        NEW.description, 
        (SELECT status_id FROM Request_Status WHERE status_name = NEW.status_id LIMIT 1),
        -- Assuming status_id and location_id are already mapped to their respective IDs in the Request_Status and Locations tables, respectively.
        (SELECT location_id FROM Locations WHERE location_name = NEW.location LIMIT 1)
        -- Assuming location_name is already mapped to its corresponding ID in the Locations table.
        )
    RETURNING request_id INTO new_request_id;

    -- Insert the request type (assuming request_type contains the type_name)
    SELECT type_id INTO type_id FROM Request_Types WHERE type_name = NEW.request_type LIMIT 1;
    IF FOUND THEN
        INSERT INTO Request_Support_Types (request_id, type_id) VALUES (new_request_id, type_id);
    END IF;

    -- Insert comments if any (considering comments column in ingest_table corresponds to request comments)
    IF NEW.comments IS NOT NULL THEN
        INSERT INTO Comments (request_id, comment_text) VALUES (new_request_id, NEW.comments);
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER ingest_data_trigger
AFTER INSERT ON ingest_table
FOR EACH ROW EXECUTE PROCEDURE replicate_ingest_data();