CREATE table ingest_table (
  request_id SERIAL PRIMARY KEY,
  name VARCHAR(100) NOT null,
  email VARCHAR(100) NOT null,
  mobile VARCHAR(20),
  description TEXT NOT NULL,
  remarks TEXT DEFAULT null,
  location varchar(10) NOT NULL,
  support_type varchar(250) NOT NULL,
  status varchar(250) NOT NULL,
  created_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP NOT NULL
);

CREATE TABLE Roles (
    role_id SERIAL PRIMARY KEY,
    role_name VARCHAR(20) UNIQUE NOT NULL
);

INSERT INTO Roles (role_name) VALUES
    ('Client'), 
    ('Agent'),
    ('Admin'),
    ('Technician'),
    ('Sales');

CREATE TABLE Users (
    user_id SERIAL PRIMARY KEY,
    email VARCHAR(100) UNIQUE NOT NULL,
    role_id INT REFERENCES Roles(role_id) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    auth_id UUID REFERENCES auth.users(id) UNIQUE NOT NULL,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL
);

CREATE TABLE Locations (
    location_id SERIAL PRIMARY KEY,
    location_name VARCHAR(20) UNIQUE NOT NULL
);

INSERT INTO Locations (location_name) VALUES 
    ('Atlanta'), 
    ('Birmingham'), 
    ('30A');

CREATE TABLE Customers (
    customer_id SERIAL PRIMARY KEY,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    phone VARCHAR(20) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    city VARCHAR(20) NOT NULL,
    state VARCHAR(2) NOT NULL,
    zipcode VARCHAR(20) NOT NULL,
    address1 VARCHAR(100) NOT NULL,
    address2 VARCHAR(100) NULL
);

CREATE TABLE Request_Types (
    request_type_id SERIAL PRIMARY KEY,
    type_name VARCHAR(50) UNIQUE NOT NULL
);

INSERT INTO Request_Types (type_name) VALUES
    ('A/V Automation'), 
    ('Electrical'), 
    ('Lighting Control'), 
    ('Network/Wi-Fi'), 
    ('Security'), 
    ('Other');

CREATE TABLE Request_Status (
    status_id SERIAL PRIMARY KEY,
    status_name VARCHAR(50) UNIQUE NOT NULL,
    description TEXT NOT NULL
);

INSERT INTO Request_Status (status_name, description) VALUES
    ('NEW REQUEST', 'The ticket is open and awaiting handling'),
    ('SCHEDULED', 'The ticket is scheduled and awaiting resolution'),
    ('PROPOSAL REQUIRED', 'A proposal from sales is required to progress this ticket'),
    ('FOLLOW UP REQUIRED', 'Ticket was unable to be resolved and requires more attention'),
    ('COMPLETED', 'The ticket has been resolved or closed');

CREATE TABLE Requests (
    request_id SERIAL PRIMARY KEY,
    customer_id INT REFERENCES Customers(customer_id) NULL,
    user_id INT REFERENCES Users(user_id) NULL,
    description TEXT NOT NULL,
    status_id INT REFERENCES Request_Status(status_id) DEFAULT 1,
    location INT REFERENCES Locations(location_id), 
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT chk_ticket_creator CHECK (
        (customer_id IS NOT NULL AND user_id IS NULL) OR
        (customer_id IS NULL AND user_id IS NOT NULL)
    )
);

CREATE TABLE Request_Support_Types (
  request_id INT NOT NULL,
  request_type_id INT NOT NULL,
  PRIMARY KEY (request_id, request_type_id),
  FOREIGN KEY (request_id) REFERENCES Requests(request_id) ON DELETE CASCADE,
  FOREIGN KEY (request_type_id) REFERENCES Request_Types(request_type_id) ON DELETE RESTRICT
);

CREATE TABLE Comments (
    comment_id SERIAL PRIMARY KEY,
    request_id INT REFERENCES Requests(request_id),
    user_id INT REFERENCES Users(user_id) DEFAULT 1,
    comment_text TEXT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Define Triggers to update updated_at column
CREATE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER users_before_update
BEFORE UPDATE ON users
FOR EACH ROW EXECUTE PROCEDURE update_updated_at_column();

CREATE TRIGGER requests_before_update
BEFORE UPDATE ON requests
FOR EACH ROW EXECUTE PROCEDURE update_updated_at_column();

CREATE TRIGGER comments_before_update
BEFORE UPDATE ON comments
FOR EACH ROW EXECUTE PROCEDURE update_updated_at_column();

-- Define Ingest Function
CREATE OR REPLACE FUNCTION replicate_ingest_data()
RETURNS TRIGGER AS $$
DECLARE
    new_customer_id INT;
    new_request_id INT;
    new_request_type_id INT;
BEGIN
    -- Check if the email already exists in the Customers table
    SELECT customer_id INTO new_customer_id FROM Customers WHERE email = NEW.email LIMIT 1;
    IF NOT FOUND THEN
        -- If not found, insert the client as a new customer and capture the customer_id

    INSERT INTO Customers (first_name, last_name, email, phone, city, state, zipcode, address1, address2, created_at) VALUES (
        -- Splitting name into first_name and last_name for simplicity
        split_part(NEW.name, ' ', 1), -- Assuming first word as first name
        split_part(NEW.name, ' ', 2), -- Assuming rest as last name
        NEW.email,
        NEW.mobile,
        '',
        '',
        '',
        '',
        '',
        NEW.created_at
    )
    RETURNING customer_id INTO new_customer_id;
    END IF;
    
    --Insert the request
    INSERT INTO Requests (customer_id, description, status_id, location) VALUES (
        new_customer_id,
        NEW.description,
        -- Assuming status_id and location_id are already mapped to their respective IDs 
        -- in the Request_Status and Locations tables, respectively.
        (SELECT status_id FROM Request_Status WHERE status_name = NEW.status LIMIT 1),
        (SELECT location_id FROM Locations WHERE location_name = NEW.location LIMIT 1)
    )
    RETURNING request_id INTO new_request_id;

    /* DOES THIS WORK FOR MULTIPLE REQUEST TYPES? */
    -- Check if the request type already exists in the Request_Types table
    -- Parse NEW.support_type for multiple comma seperated values and insert into Request_Support_Types table

    -- Splitting support_type into multiple values
    WITH support_types AS (
        SELECT unnest(string_to_array(NEW.support_type, ',')) AS support_type
    )
    -- Insert the support types into the Request_Support_Types table
    SELECT request_type_id INTO new_request_type_id FROM Request_Types WHERE type_name = NEW.support_type LIMIT 1;
    IF FOUND THEN
        INSERT INTO Request_Support_Types (request_id, request_type_id) VALUES (new_request_id, new_request_type_id);
    END IF;

    -- Insert comments if any (considering remarks column in ingest_table corresponds to request comments)
    IF NEW.remarks IS NOT NULL THEN
        INSERT INTO Comments (request_id, comment_text) VALUES (new_request_id, NEW.remarks);
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Ingest Table Trigger
CREATE TRIGGER ingest_data_trigger
AFTER INSERT ON ingest_table
FOR EACH ROW EXECUTE PROCEDURE replicate_ingest_data();

/*-- Enable RLS (row-level security) and policies will be defined as per user roles and access requirements
ALTER TABLE Requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE Users ENABLE ROW LEVEL SECURITY;
ALTER TABLE Comments ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Can view own user data." ON users FOR SELECT USING (auth.uid() = Users.auth_id);
CREATE POLICY "Can update own user data." ON users FOR SELECT USING (auth.uid() = Users.auth_id);
CREATE POLICY "Can view all user data." ON users FOR SELECT USING (true);
CREATE POLICY "Can view all data." ON requests, users, comments FOR SELECT USING (Users.role_id = 4);
CREATE POLICY "Can create data." ON requests, users, comments FOR INSERT WITH CHECK (Users.role_id = 4);
CREATE POLICY "Can update data." ON requests, users, comments FOR UPDATE USING (Users.role_id = 4);
CREATE POLICY "Can delete data." ON requests, users, comments FOR DELETE USING (Users.role_id = 4);
CREATE POLICY "Can view all data." ON request_support_types FOR SELECT USING (true);
CREATE POLICY "Can create data." ON request_support_types FOR INSERT WITH CHECK (true);
CREATE POLICY "Can update data." ON request_support_types FOR UPDATE USING (true);
CREATE POLICY "Can delete data." ON request_support_types FOR DELETE USING (true);
CREATE POLICY "Can view all data." ON request_status FOR SELECT USING (true);
*/


